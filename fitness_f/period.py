
from __future__ import print_function
from dolfin import *
import numpy as np
import matplotlib.pyplot as plt
# from mshr import *
set_log_level(40)
class PeriodicBoundary(SubDomain):
    def __init__(self, vertices, tolerance=DOLFIN_EPS):
        """ vertices stores the coordinates of the 4 unit cell corners"""
        SubDomain.__init__(self, tolerance)
        self.tol = tolerance
        self.vv = vertices
        self.a1 = self.vv[1,:]-self.vv[0,:] # first vector generating periodicity
        self.a2 = self.vv[3,:]-self.vv[0,:] # second vector generating periodicity
        # check if UC vertices form indeed a parallelogram
        assert np.linalg.norm(self.vv[2, :]-self.vv[3, :] - self.a1) <= self.tol
        assert np.linalg.norm(self.vv[2, :]-self.vv[1, :] - self.a2) <= self.tol
        
    def inside(self, x, on_boundary):
        # return True if on left or bottom boundary AND NOT on one of the 
        # bottom-right or top-left vertices
        return bool((near(x[0], self.vv[0,0] + x[1]*self.a2[0]/self.vv[3,1], self.tol) or 
                     near(x[1], self.vv[0,1] + x[0]*self.a1[1]/self.vv[1,0], self.tol)) and 
                     (not ((near(x[0], self.vv[1,0], self.tol) and near(x[1], self.vv[1,1], self.tol)) or 
                     (near(x[0], self.vv[3,0], self.tol) and near(x[1], self.vv[3,1], self.tol)))) and on_boundary)

    def map(self, x, y):
        if near(x[0], self.vv[2,0], self.tol) and near(x[1], self.vv[2,1], self.tol): # if on top-right corner
            y[0] = x[0] - (self.a1[0]+self.a2[0])
            y[1] = x[1] - (self.a1[1]+self.a2[1])
        elif near(x[0], self.vv[1,0] + x[1]*self.a2[0]/self.vv[2,1], self.tol): # if on right boundary
            y[0] = x[0] - self.a1[0]
            y[1] = x[1] - self.a1[1]
        else:   # should be on top boundary
            y[0] = x[0] - self.a2[0]
            y[1] = x[1] - self.a2[1]


def getfit(mesh):
    vertices = np.array([[0., 0.],
                     [1, 0],
                     [1, 1],
                     [0, 1]])
    subdomains = MeshFunction("size_t", mesh, 1)
    Em = 50e3
    num = 0.2
    Er = 1
    nur = 0.3
    material_parameters = [(Er, nur)]
    nphases = len(material_parameters)
    def eps(v):
        return sym(grad(v))
    def sigma(v, i, Eps):
        E, nu = material_parameters[i]
        lmbda = E*nu/(1+nu)/(1-2*nu)
        mu = E/2/(1+nu)
        return lmbda*tr(eps(v) + Eps)*Identity(2) + 2*mu*(eps(v)+Eps)

    Ve = VectorElement("CG", mesh.ufl_cell(), 2)
    Re = VectorElement("R", mesh.ufl_cell(), 0)
    W = FunctionSpace(mesh, MixedElement([Ve, Re]), constrained_domain=PeriodicBoundary(vertices, tolerance=1e-10))
    V = FunctionSpace(mesh, Ve)

    v_,lamb_ = TestFunctions(W)
    dv, dlamb = TrialFunctions(W)
    w = Function(W)
    dx = Measure('dx')(subdomain_data=subdomains)

    Eps = Constant(((0, 0), (0, 0)))
    F = sum([inner(sigma(dv, i, Eps), eps(v_))*dx(i) for i in range(nphases)])
    a, L = lhs(F), rhs(F)
    a += dot(lamb_,dv)*dx + dot(dlamb,v_)*dx

    def macro_strain(i):
        """returns the macroscopic strain for the 3 elementary load cases"""
        Eps_Voigt = np.zeros((3,))
        Eps_Voigt[i] = 1
        return np.array([[Eps_Voigt[0], Eps_Voigt[2]/2.], 
                        [Eps_Voigt[2]/2., Eps_Voigt[1]]])
    def stress2Voigt(s):
        return as_vector([s[0,0], s[1,1], s[0,1]])

    Chom = np.zeros((3, 3))
    for (j, case) in enumerate(["Exx", "Eyy", "Exy"]):
        # print("Solving {} case...".format(case))
        Eps.assign(Constant(macro_strain(j)))
        try:
            solve(a == L, w, [], solver_parameters={"linear_solver": "cg"})
        except Exception as e:
            print("error")
            return -999999999999,-999999999999
        (v, lamb) = split(w)
        Sigma = np.zeros((3,))
        for k in range(3):
            Sigma[k] = assemble(sum([stress2Voigt(sigma(v, i, Eps))[k]*dx(i) for i in range(nphases)]))/1
        Chom[j, :] = Sigma
    lmbda_hom = Chom[0, 1]
    mu_hom = Chom[2, 2]
    # print(Chom)
    # y = SpatialCoordinate(mesh)
    # plt.figure()
    # p = plot(0.5*(dot(Eps, y)+v), mode="displacement", title=case)
    # plt.colorbar(p)
    # plt.show()
    # plt.savefig('deformed.png')
    # print(-(Chom[0,0]+Chom[1,1])/2.,Chom[0,1])
    return (Chom[0,0]+Chom[1,1])/2.,-Chom[0,1]
    # return Chom[0,1]/Chom[0,0],Chom[0,0]
    #max avg 0011 min 01 10
    # print(np.array_str(Chom, precision=2))
